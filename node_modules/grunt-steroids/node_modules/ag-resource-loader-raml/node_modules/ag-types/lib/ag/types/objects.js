(function() {
  var Failure, Success, assert, check, mapValues, objectSequence, objects, pairs, primitive, zipObject, _ref;

  zipObject = require('lodash-node/modern/arrays/zipObject');

  mapValues = require('lodash-node/modern/objects/mapValues');

  pairs = require('lodash-node/modern/objects/pairs');

  _ref = require('data.validation'), Success = _ref.Success, Failure = _ref.Failure;

  assert = require('../assert');

  check = require('../check');

  primitive = require('./primitives');

  objectSequence = function(nameValidationPairs) {
    var failures, name, result, validation;
    failures = [];
    result = (function() {
      var _i, _len, _ref1, _results;
      _results = [];
      for (_i = 0, _len = nameValidationPairs.length; _i < _len; _i++) {
        _ref1 = nameValidationPairs[_i], name = _ref1[0], validation = _ref1[1];
        _results.push(validation.fold(function(failure) {
          failures = failures.concat(failure);
          return [name, null];
        }, function(success) {
          return [name, success];
        }));
      }
      return _results;
    })();
    if (failures.length > 0) {
      return Failure(failures);
    } else {
      return Success(zipObject(result));
    }
  };

  module.exports = objects = {
    Property: function(name, type) {
      if (type == null) {
        type = primitive.Any;
      }
      assert.isFunction(type);
      return function(object) {
        return ((object != null ? object[name] : void 0) != null ? type(object[name]) : type(null)).leftMap(function(errors) {
          var result;
          result = {};
          result[name] = errors;
          return result;
        });
      };
    },
    Object: function(memberTypes) {
      var propertyNamesToTypes;
      propertyNamesToTypes = mapValues(memberTypes, function(type, name) {
        assert.isFunction(type);
        return objects.Property(name, type);
      });
      return function(object) {
        return objectSequence(pairs(mapValues(propertyNamesToTypes, function(propertyType) {
          return propertyType(object);
        })));
      };
    },
    Map: function(type) {
      assert.isFunction(type);
      return function(input) {
        if (!check.isObject(input)) {
          return Failure(["Input was of type " + (check.typeAsString(input)) + " instead of object"]);
        } else {
          return objectSequence(pairs(mapValues(input, function(throwawayValue, propertyName) {
            return objects.Property(propertyName, type)(input);
          })));
        }
      };
    }
  };

}).call(this);
