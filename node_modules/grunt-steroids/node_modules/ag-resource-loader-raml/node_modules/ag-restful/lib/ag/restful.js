(function() {
  var Failure, Promise, ajax, assert, deepDefaults, responseValidator, rest, restMethodBuilder, restful, types, urlify, validationToPromise, validatorToPromised, validatorToResponseValidator, _,
    __slice = [].slice;

  _ = {
    mapValues: require('lodash-node/modern/objects/mapValues'),
    partialRight: require('lodash-node/modern/functions/partialRight'),
    merge: require('lodash-node/modern/objects/merge'),
    defaults: require('lodash-node/modern/objects/defaults')
  };

  assert = require('assert-plus');

  Promise = require('bluebird');

  types = require('ag-types');

  Failure = require('data.validation').Failure;

  ajax = require('./restful/ajax');

  validationToPromise = function(validation) {
    return validation.fold(function(errors) {
      return Promise.reject(new Error(JSON.stringify(errors)));
    }, function(value) {
      return Promise.resolve(value);
    });
  };

  validatorToPromised = function(validator) {
    return function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return validationToPromise(validator.apply(null, args));
    };
  };

  deepDefaults = _.partialRight(_.merge, _.defaults);

  validatorToResponseValidator = function(validator) {
    var responseBodyValidator, responseCode;
    if (typeof validator === 'function') {
      return types.OneOf([types.Property('body', validator), types.Property('text', validator)]);
    } else {
      return types.OneOf((function() {
        var _results;
        _results = [];
        for (responseCode in validator) {
          responseBodyValidator = validator[responseCode];
          _results.push(validatorToResponseValidator(responseBodyValidator));
        }
        return _results;
      })());
    }
  };

  responseValidator = function(responseDataValidator) {
    return (function(validateResponse) {
      return function(response) {
        if (response.error) {
          return Failure([response.error]);
        } else {
          return validateResponse(response);
        }
      };
    })(validatorToResponseValidator(responseDataValidator));
  };

  urlify = function(input) {
    var item, _i, _len, _results;
    if (input == null) {
      return '';
    }
    switch (Object.prototype.toString.call(input)) {
      case '[object Object]':
        return _.mapValues(input, urlify);
      case '[object Array]':
        _results = [];
        for (_i = 0, _len = input.length; _i < _len; _i++) {
          item = input[_i];
          _results.push(urlify(item));
        }
        return _results;
      default:
        return encodeURIComponent(input);
    }
  };

  rest = {
    getter: function(_arg) {
      var options, path, receive;
      path = _arg.path, receive = _arg.receive, options = _arg.options;
      assert.func(path, 'path');
      assert.func(receive, 'receive');
      assert.optionalObject(options, 'options');
      return function() {
        var args, head, query, tail, url, urlArgs, _i, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        head = 2 <= args.length ? __slice.call(args, 0, _i = args.length - 1) : (_i = 0, []), tail = args[_i++];
        _ref = typeof tail === 'object' ? [head, tail] : [args, {}], urlArgs = _ref[0], query = _ref[1];
        url = path.apply(null, urlify(urlArgs));
        return ajax.request('get', url, _.defaults({
          query: query
        }, options || {})).then(validatorToPromised(receive));
      };
    },
    poster: function(_arg) {
      var doPostRequest, options, path, receive, send;
      path = _arg.path, send = _arg.send, receive = _arg.receive, options = _arg.options;
      assert.func(path, 'path');
      assert.func(send, 'send');
      assert.func(receive, 'receive');
      assert.optionalObject(options, 'options');
      doPostRequest = function(data) {
        var url;
        url = path(urlify(data));
        return ajax.request('post', url, _.defaults({
          data: data
        }, options || {}));
      };
      return function(data) {
        return validationToPromise(send(data)).then(doPostRequest).then(validatorToPromised(receive));
      };
    },
    deleter: function(_arg) {
      var options, path;
      path = _arg.path, options = _arg.options;
      return function() {
        var args, url;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        url = path.apply(null, urlify(args));
        return ajax.del(url, options || {});
      };
    },
    putter: function(_arg) {
      var doPutRequest, options, path, receive, send;
      path = _arg.path, send = _arg.send, receive = _arg.receive, options = _arg.options;
      assert.func(path, 'path');
      assert.func(send, 'send');
      assert.func(receive, 'receive');
      assert.optionalObject(options, 'options');
      doPutRequest = function(args) {
        var url;
        url = path.apply(null, urlify(args));
        return function(data) {
          return ajax.request('put', url, _.defaults({
            data: data
          }, options || {}));
        };
      };
      return function() {
        var args, data, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), data = arguments[_i++];
        return validationToPromise(send(data)).then(doPutRequest(args)).then(validatorToPromised(receive));
      };
    },
    uploader: function(_arg) {
      var receive;
      receive = _arg.receive;
      assert.func(receive, 'receive');
      return function(url, file, options) {
        if (options == null) {
          options = {};
        }
        return ajax.request('put', url, _.defaults({
          type: 'application/octet-stream',
          data: (function() {
            switch (true) {
              case Buffer.isBuffer(file):
                return file.toString();
              default:
                return file;
            }
          })()
        }, options || {})).then(validatorToPromised(receive));
      };
    }
  };

  restMethodBuilder = function(options) {
    var withDefaultOptions;
    withDefaultOptions = function(resourceBuilder) {
      return function(resourceDescription) {
        return resourceBuilder(deepDefaults(resourceDescription, {
          options: options
        }));
      };
    };
    return {
      get: withDefaultOptions(rest.getter),
      post: withDefaultOptions(rest.poster),
      "delete": withDefaultOptions(rest.deleter),
      put: withDefaultOptions(rest.putter),
      upload: rest.uploader,
      response: responseValidator,
      request: function(projection) {
        return function(data) {
          var key, sikrits, value;
          sikrits = {};
          for (key in data) {
            value = data[key];
            if (!(0 === key.indexOf('__'))) {
              continue;
            }
            sikrits[key] = value;
            delete data[key];
          }
          return projection(data).map(function(requestBody) {
            return _.merge({}, requestBody, sikrits);
          });
        };
      }
    };
  };

  module.exports = restful = function(options, apiDescriptor) {
    return apiDescriptor(restMethodBuilder(options));
  };

}).call(this);
